# 2D / Global MEM Usage

Purpose: fit τ–τ maps or correlated decay stacks jointly (global constraints).

Inputs
- time: (n_times,)
- corr_maps or decays: shape depends on API (examples below)
- tau: lifetime grid
- optional: initial 2D A_init (matrix NxN)

Config options (KiltConfig)
- global_fit=True
- A_init: initial 2D distribution
- use_irf_convolution, irf, optimize_irf_shift, optimize_eta, eta schedule
- rounds_per_eta, maxiter

Typical 2D example (FDC correlation maps)
```python
import numpy as np
import jax.numpy as jnp
from pyKilt import KiltConfig, run_ilt_2d

time = np.linspace(0, 15, 500)
n_bins = 200
tau = jnp.linspace(0.3, 7, n_bins)
irf = np.exp(-((time - 0.5)**2)/(2*0.25**2)); irf /= irf.sum()

# build a simple initial A_init (two Gaussian blobs)
X, Y = jnp.meshgrid(tau, tau)
A_init = jnp.exp(-((X-0.5)**2 + (Y-0.5)**2)/(2*1**2)) \
       + jnp.exp(-((X-3)**2 + (Y-3)**2)/(2*1**2))
A_init /= A_init.sum()

cfg2 = KiltConfig(
    optimize_irf_shift=True,
    irf_shift_list=range(2,3),
    optimize_eta=True,
    eta_start=1e-4, eta_end=1e-3, eta_rounds=1,
    rounds_per_eta=1, maxiter=2000,
    use_irf_convolution=True, irf=irf,
)

# corr_maps: your FDC-extracted correlation maps array
res2d = run_ilt_2d(time, tau, corr_maps, cfg2, A_init=A_init)
```

Tips
- Provide a sensible A_init when possible to speed convergence.
- Visualize intermediate trials (res["trials"]) to check annealing behavior.